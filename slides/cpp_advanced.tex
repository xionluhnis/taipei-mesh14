
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Advanced C++ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\pointedsl{
	Advanced C++
}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
\frametitle{References}
\begin{lstlisting}
// passed by reference
void swap_ref(int &x, int &y){
    int tmp = x;
    x = y;
    y = tmp;
}
int a = 1, b = 2;
swap_ref(a, b);
// good! a=2, b=1
\end{lstlisting}
\misc{
	\emph{References} are syntactic sugar for pointers when passing variables to functions or retrieving the value they return.
}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Templating}
\begin{lstlisting}
template< typename T >
T sum(T a, T b){
    T c = a + b;
    return c;
}
\end{lstlisting}
\misc{
	Function (and class) \emph{templates} provides a way to abstract the notion of type.
	
	Here, the type \ctext{T} is resolved by the compiler when \ctext{sum} is used.
	It only requires an operator \ctext{+} to work.
}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Templating (2)}
\begin{lstlisting}
int c = sum(1, 2);
float d = sum(1.0f, 2.0f);
float e = sum<float>(1, 2.0f);
\end{lstlisting}
\misc{
	The type \ctext{T} can sometimes by inferred. When it cannot, one must specify it.
}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[fragile]
\frametitle{Classes}
\begin{lstlisting}
// declaration
template <typename T, int dim>
struct vec {
    typedef vec<T, dim> this_type;
    T val[dim];
    vec(T a, T b);
    double sqLength() const;
    static this_type constant(T a);
};
\end{lstlisting}
\misc{
	Classes (keyword \ctext{class}) and structures (keyword \ctext{struct}) describe custom types made
	of properties (\ctext{val}) and methods (\ctext{sqLength}).
}
\end{frame}

\begin{frame}[fragile]
\frametitle{Classes (2)}
\begin{lstlisting}
// definitions
template <typename T, int dim>
double vec<T, dim>::sqLength() {
    T sum = 0;
    for(int i = 0; i < dim; ++i)
        sum += val[i] * val[i];
    return sum;
}
\end{lstlisting}
\misc{
	Definition of methods (including the constructor \ctext{vec} and/or its possible destructor \ctext{~vec} can be done separately.
}
\end{frame}

\begin{frame}[fragile]
\frametitle{Classes (3)}
\begin{lstlisting}
// type alias
typedef vec<float, 2> vec2f;

// class usage
vec2f a = vec2f::constant(2);
float d = a.sqLength(); // d=8
\end{lstlisting}
\misc{
	Static properties and methods are called with the namespace operator (\ctext{::}) whereas
	instance properties and methods are accessed with the dot operator.
}
\end{frame}

\begin{frame}[fragile]
\frametitle{Operator overloading}
\begin{lstlisting}
vec2f operator +(const vec2f &v1,
                 const vec2f &v2){
    vec2f x;
    for(int i = 0; i < 2; ++i)
        x.val[i] = v1.val[i] + v2.val[i];
    return x;
}

// usage
vec2f a, b;
// hidden: initialization of a and b
vec3f c = a + b;
\end{lstlisting}
\end{frame}
