
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% Storing data on the mesh %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\fbckg{backgrounds/blank2}
\setbeamercolor{frametitle}{fg=gray}
\begin{frame}
\pointedsl{
	Properties
}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}
\frametitle{Properties}
\misc{
	\textbf{Properties} of any kind (use of template) can be associated to
	\emph{vertices}, \emph{half-edges}, \emph{edges} or \emph{faces}.
	
	\begin{enumerate}
		\item How do we create them?
		\item How do we access them?
	\end{enumerate}
}
\end{frame}

\begin{frame}[fragile]
\frametitle{Property code}
\lstset{ numbers=none, xleftmargin=0cm }
\begin{lstlisting}
typedef Surface_mesh Mesh;

// storing Color data on each vertex
Mesh::Vertex_property<Color> colors;
colors = mesh.vertex_property<Color>("v:color");

// access property for vertex v
Mesh::Vertex v;
Color c = colors[v]; // get property
colors[v] = Color(0, 0, 0); // set black

// default position property
Mesh::Vertex_property<Point> points;
points = mesh.vertex_property<Point>("v:point");
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Property code}
\begin{lstlisting}
// for element Xxx, storing type T
Mesh::Xxx_property<T> prop;
prop = mesh.xxx_property<T>(name);
// access with x of type Xxx
T t = prop[x];
\end{lstlisting}
\misc{
	where \ctext{Xxx} is one from 
	\ctext{Vertex}, \ctext{Face}, \ctext{Edge} or \ctext{Halfedge}.
	
	\phantom{x}
	
	The storage type \ctext{T} can be any common type (color, location, integer, float, etc.).
}
\end{frame}

\begin{frame}[fragile]
\frametitle{Normal properties}
\misc{
	Normals (of type \ctext{Normal}) can be computed automatically and are available in two flavors: per-vertex (property \ctext{"v:normal"}) of per-face (property \ctext{"f:normal"}).
}
\lstset{ numbers=none, xleftmargin=0cm}
\begin{lstlisting}
// compute normals
mesh.update_vertex_normals();

// access normals
Mesh::Vertex_property<Normal> nrs;
nrs = mesh.vertex_property<Normal>("v:normal");
Normal n = nrs[v];
\end{lstlisting}
\end{frame}
